
= Rangeary - Multiple Range(Extd) class

This package defines Rangeary class, which contains multiple
1-dimensional ranges ({RangeExtd}[http://rubygems.org/gems/range_extd] objects).  For example, a multiple
range of

   0.5 < x <= 2.5,  6.0 <= x < 8.0,  10.0 <= x (<= Infinity)

for <tt>x</tt> can be defined in this class.

The element objects for +Rangeary+ can be anthing that can form
RangeExtd objects, not only Numeric (or Real) but anything
Comparable.  +Rangeary+ accepts the built-in Range-class objects for
the elements in initialization, too, providing it is a valid
(<tt>Range#valid? == true</tt>) ones for the
{RangeExtd}[https://rubygems.org/gems/range_extd] class (n.b., most Range
objects are valid, but +(true..true)+ is not, for example, which would
not make sense to constitute multiple ranges).

All the four standard logical operations, that is, negation
(<tt>~</tt>), conjunction (<tt>&</tt> or <tt>*</tt>), disjunction
(<tt>|</tt> or <tt>+</tt>) and exclusive disjunction (<tt>^</tt> or
<tt>xor</tt>) are defined, as well as subtraction (<tt>-</tt>).

{Rangeary} objects are immutable - once it is created, you cannot
alter the contents.

{Rangeary} is implemented as a sub-class of Array, works as an array of
RangeExtd, and inherits most of the methods. Thus, you can apply most
operations to {Rangeary} that Array accpets, within the restriction of
immutability of {Rangeary}; for example, +Array#push+ is disabled for
{Rangeary}. In addition, {Rangeary} offers several
methods that directly work on its element as a range.  In the above
example, <tt>#cover?(1.0)</tt> (like +Range#cover?+) returns true, whereas
<tt>#cover?(9.0)</tt>, false.


With this class, logical operations of 1-dimensional range objects are
now possible and easy.
I hope you find it to be useful.

=== News: Library locations and support for Beginless Range

**IMPORTANT**: The path for the library is moved up by one
directory in {Rangeary} Ver.2 from Ver.1 (same as the change in +RangeExtd+) in order that the
location follows the Ruby Gems convention.  In short, the standard way
to require is +require "rangeary"+, the path of which used to be "rangeary/rangeary"

Version of {Rangeary} is now 2.0.

Ruby 2.7 supports {Beginless range}[https://rubyreferences.github.io/rubychanges/2.7.html#beginless-range].

+Rangeary+ (Ver.2) also supports it now, requiring
{RangeExtd}[https://rubygems.org/gems/range_extd] Ver.2 (or later).

==== News: Endless Range supported

Now, as of 2019 October, this fully supports {Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
introduced in Ruby 2.6.  It is released as Version 1.* finally!


== Install

First, you need {RangeExtd}[https://rubygems.org/gems/range_extd] class library Ver.2 or later, which is in gem:

  gem install range_extd

Or, get it from
{https://rubygems.org/gems/range_extd}

and follow the INSTALL section in the manual of
{RangeExtd}[https://rubygems.org/gems/range_extd]
for manual installation.

Then, install this library with

  gem install rangeary

A file

  rangeary.rb

should be installed in one of your <tt>$LOAD_PATH</tt>.
Alternatively, get it from
{http://rubygems.org/gems/rangeary}

Then all you need to do is

  require 'rangeary'

in your Ruby script (or irb).  The library files like
(Note the path used to be, in Rangeary Ver.1 or earlier), "rangeary/rangeary".)

{Rangeary} Ver.2, along with RangeExtd, works in only Ruby 2.7 or later.

Have fun!


== Simple Examples

=== How to create a Rangeary instance

Here are some simple examples.

   r1 = RangeExtd(?a...?d, true) # => a<...d
   ra = Rangeary(?g..?h, r1)     # => [a<...d, g..h]
   Rangeary(RangeExtd::NONE)     # => [RangeExtd::NONE]
   Rangeary(RangeExtd::NONE, 1..5, 3...7)  # => [1...7]
   Rangeary(true..true)          # => ArgumentError

Basically, <tt>Rangeary()</tt> or <tt>Rangeary.new()</tt> accepts
an arbitrary number of either Range, RangeExtd, {Rangeary}, or a
combination of them.  Note Range objects that return false in
+Range#valid?+ raise an exception.

For more detail and examples, see {Rangeary.initialize}.


=== Practical application examples

   ra.to_a                       # => ["a"<..."d", "g".."h"]
   ra.cover?("a")                # => false
   ra.cover?("b")                # => true
   ra.end                        # => "h"
   ra.each do |i|
     print i.begin
   end    # => self ( "ag" => STDOUT )
   ra.each_element do |i|
     print i
   end    # => self ( "bcgh" => STDOUT )

   rb = Rangeary(6...9, 2..4)    # => [2..4, 6...9]
   rb + Rangeary(3..7)           # => [2...9]
   rb - Rangeary(3..7)           # => [2...3, RangeExtd(7,'<...',9)]
   rb * Rangeary(4..5, 8..10)    # => [4..4, 8...9]
   ~rb                           # => [-Float::INFINITY...2, RangeExtd(4,'<...',6), 9..Float::INFINITY]

   rc = Rangeary(?d...?x, negative: ?a, positive: ?z)
   ~rc                           # => [?a...?d, ?x..?z]

where +~rb+ is equivalent to +rb.negation+.  In the last example, it
provides the user-defined *infinities*.

Most of the methods that are in the built-in Array can be used, as long as
it does not violate the immutability of {Rangeary} objects, such as
+Array#push+.


== Description

Once the file <tt>rangeary.rb</tt> is required, the class +Rangeary+ is defined, in
addtion to those defined in the {RangeExtd}[https://rubygems.org/gems/range_extd] library
(<tt>RangeExtd</tt>, <tt>RangeExtd::Infinity</tt>, and <tt>RangeExtd::Nowhere</tt>).

=== Rangeary Class

{Rangeary} objects are immutable, the same as Range and RangeExtd.
Hence once an instance is created, it would not change.

How to create an instance is explained above (in the Example
sections).  Any attempt to try to create an instance with one of
elements being not "valid" as a range, that is, of which +Range#valid?+ returns
false, raises an exception (<tt>ArgumentError</tt>), and fails.

Note +RangeExtd+ (or +Range+) objects given as arguments to initialize +Rangeary+
instances can contain negative and/or positive infinity objects.
Since Ruby 2.7 and 2.6,
{Beginless range}[https://rubyreferences.github.io/rubychanges/2.7.html#beginless-range]
and {Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
are respectively introduced. They correspond to more conventional
{RangeExtd::Infinity}[https://www.rubydoc.info/gems/range_extd/RangeExtd/Infinity]
objects, which Rangeary has supported since its first release.

The built-in borderless Ranges and +RangeExtd::Infinity+ objects are
similar but are conceptually slightly different; the difference is
similar to that between borderless Ranges and +Float::INFINITY+.
See the reference document of {RangeExtd}[http://rubygems.org/gems/range_extd]
for detail.

In default, when Ranges that contain infinities, be it built-in borderless Ranges
or +Float::INFINITY+ or +RangeExtd::Infinity+ are given to {Rangeary},
+Rangeary+ use them.  Alternatively, a user can specify their own
infinity objects; for example, you may provide +"a"+ as the negative
infinity for +Rangeary+ with String Ranges.  If nothing is provided
and yet if +Rangeary+ requires one(s), which may happen, for example,
in an operation of negation, +Rangeary+ uses +Float::INFINITY+ for
Numeric (Real numbers) and +RangeExtd::Infinity+ for anything else in
default. 
See {Rangeary.initialize} for detail.

When multiple ranges are given in initializing, they are internally sorted in
storing, and if there are any overlaps among any of the elements, they
are treated as disjunction (that is, simple summation).  This means that
the objects a {Rangeary} instance holds internally can be different from 
the objects given in initialization, namely, their <tt>#object_id</tt> may be
different.  In particular, if built-in Range objects are given,
they are always converted into RangeExtd objects internally.

If any of the given range in the initialization is "empty", that is,
+Range#empty?+ returns true, they are ignored, unless all of the
ranges given are empty ranges, in which case the "smallest" one will be
preserved.

If the result of the operation is empty, only the element of the
resultant {Rangeary} is +RangeExtd::NONE+, and hence
{Rangeary#empty_element?} will return true.

For any Rangeary objects, <tt>(Rangeary#to_a).size</tt> returns always
positive and not zero for this reason, or +Rangeary#empty?+ returns
always false, as +Rangeary#empty?+ is a method inherited from Array.
Use {Rangeary#empty_element?} instead to check whether the instance is
*practically* empty, or in other words, an empty range.

   Rangeary(RangeExtd::NONE).empty?          # => false
   Rangeary(RangeExtd::NONE).empty_element?  # => true

As mentioned, all the methods of Array but a few are inherited
to this {Rangeary} class, and they in principle work as if +Rangeary+ is an Array of
+RangeExtd+ (which is indeed the case!).  Four methods work differently: {Rangeary#+} and
{Rangeary#*} are the alias to {Rangeary#disjunction} and
{Rangeary#conjunction}, repectively.  {Rangeary#===} performs
+Range#===+ for all the Rangeary element ranges and return true if any
of them returns true.  Therefore, {Rangeary#===}(RangeExtd(**))
returns always false.  Also, +#length+
and +#reverse+ are undefined.  Finally, {Array#==} is modified (see below).

All the other methods operating on the element ranges, rather than
on the ranges themselves, have a suffix of <tt>_element</tt>, if there
is the same method name in the built-in Array.  For example,
+Rangeary#size+ returns the number of +RangeExtd+ objects it holds as an Array,
and {Rangeary#size_element} returns the total +Range#size+ of all
the RangeExtd objects it holds.

   Rangeary(1..3, 5..8).size          # => 2
   Rangeary(1..3, 5..8).size_element  # => 7

Or, {Rangeary#flatten_element} returns the concatnated
single array of +Rangeary#to_a+ for all the discrete range elements
(the element ranges have to be discrete like Integer).

The complete reference of the class and methods is available at
{Rubygems website}[http://rubygems.org/gems/rangeary], or you can compile the
reference with +yard+ from the source package (+make doc+ at the
package root directory would do).

===  Infinities

The infinities are vital in the logical operation of Rangeary.
Without it, negation could not be definied, and other logical
operations are also closely related to it; for example, *subtraction*
is basically a combination of *negation* and *conjunction*.

To determine what the positive and negative infinities for the given
elements is not a trivial task. In default, +nil+ is used except for
+Numerics+ (Integer, Rational, Float etc), for which +Float::INFINITY+
is used. Note that the default use to be 
<tt>RangeExtd::Infinity::POSITIVE</tt> and  <tt>RangeExtd::Infinity::NEGATIVE</tt>
defined in {RangeExtd}[http://rubygems.org/gems/range_extd] 
up to Rangeary Ver.1, where both beginless and endless Ranges were not
been introduced or supported. Rangeary Ver.2 changes the specification
to be in line with the latest Ruby Range.

Alternatively, a user can specify their own infinities in
initialization of {Rangeary} with options of +positive:+ and
+negative:+. The boundaries at the opposite polarities usually should
match unless they are comparable or either of them is +nil+.

Here are examples how infinities work with {Rangeary}. In the first
example, infinities are implicitly contained in the specified Range.
Then, the infinities are internally preserved throughout operations.
Note that the first set of 2 operations and the second set of a single operation
means the same.

  r1 = Rangeary(nil..Float::INFINITY).conjunction( RangeExtd::NONE )
    # => Rangeary(RangeExtd::NONE)
  r2 = r1.negation
    # => Rangeary(nil..Float::INFINITY)

  ~(Rangeary(nil..Float::INFINITY) * RangeExtd::NONE)
    # => Rangeary(nil..Float::INFINITY)

In the second example below, a negative infinity of "+d+" is explicitly specified
for a Range of single alphabet String.

  Rangeary("f".."k", negative: "d").negation
    # => Rangeary("d"..."f", "k"<..nil)

where +"k"<..nil+ means a begin-exclude Range or +RangeExtd("k"..nil, true)+.

A note of caution is that once an infinity is defined for a Rangeary object, any other
Rangeary objects with which operations are performed should be in line with the
same infinities.  If you specify your own infinities, it is advised to
do so at the beginning.  And once the infinities have been manually
set, it is advised not to modify them (although this library should
handle such changes appropriately -- see the method document for detail)
because unexpected errors may occur. Here is a set of examples. 

  r3 =  Rangeary("f".."k", negative: "d")
  r4 = ~r3
    # => Rangeary("d"..."f", "k"<..nil)
   _ =   Rangeary(r4, positive: "t")  # raises ArgumentError(!):
                                      # because "t" is smaller than end of Endless Range
  r6 =   Rangeary(r3, positive: "t")  # OK: because end of r3 is only "k"
  r7 =  ~r6
    # => Rangeary("a"..."d", "f".."k") # differs from r4 in the second Range

In the example above, +r4+, which is the negation of +r3+ is
"Endless", i.e., the last Range in +r3+ is an endless Range.
So, attempting to set a positive infinity of "+t+" raises an Exception (+ArgumentError+).

If the new infinity(ies) does not contradict the current contents (like +r6+), it
is set accordingly and the subsequent operations (e.g., +r7+) adopt the value
(though you should make sure it is exactly what you want).


==== Algorithm of determining default infinities

Callers can supply user-defined infinity objects for both or either
positive and negative infinity and in that case they are accepted
as the infinities with the highest priority, though ArgumentError might be
issued if they contradict the elements; for example, if a {Rangeary}
instance consists of an array of Integer Ranges (RangeExtd) like +(3..8)+,
and yet if String "abc" is specified as an infinity, it *contradicts*
the elements in the sense they are not comparable.

Internally, the {Rangeary} instance has a Hash extended with {Rangeary::Util::HashInf},
which can be obtained with {#instances}.
It has only 2 keys of +:negative+ and +:positive+, the values of which
are the current best-guessed or definite infinities.  The Hash also
holds status information for each polarity with 3 levels of

1. <tt>false</tt>
2. <tt>:guessed</tt>
3. <tt>:definite</tt>

It is +false+ only when the Rangeary is absolutely void with no
information about the contents: +Rangeary(RangeExtd::NONE)+.

If the user explicitly specifies a boundary in the optional arguments in
initialization of {Rangeary}, it is accepted in principle with an associated status of <tt>:definite</tt>.

If the user-specified main arguments in initialization contain
a (potentially multiple) {Rangeary}, their defined infinities are
inherited with their associated statuses. 

Also, user-supplied Range-s or RangeExtd-s to the arguments in
initialization of {Rangeary} always have, except for
+RangeExtd::NONE+, concrete boundary values, which can be +nil+.

If one of the boundaries of a Range (n.b., it is *not* Rangeary) contains either +nil+ or one of infinite values
(which is checked with +RangeExtd::Infinity.infinite?+, where in practice
a duck-typing check is performed, using the method +infinite?+), then
it is accepted as an infinite value with an associated status of <tt>:definite</tt>.

Otherwise,

1. if a boundary value is a (real-type) Numeric, +Float::INFINITY+ (or
   its negative,
2. or otherwise, +nil+

is set as an infinity of the boundary with an associated status of +:guessed+.

Note that the priority used to be different up to Rangeary Ver.1; +nil+ was not used and
instead the +RangeExtd::Infinity+ objects were used. It was because
the beginless Range (and endless Range before Ruby-2.6) has not been defined before
Ruby 2.7.  Now they are defined, it is only natural to use +nil+ as the
default infinities in both ends, hence the change in specification in
{Rangeary} Ver.2.
  
Usually the arguments given in initialization of a {Rangeary} contain
more than one set of infinities candidate, unless only a single
argument of either Range (or its subclass instance) with no optional
arguments is given.  The priority is judged in the following order:

1. the optional arguments
2. an associated status of <tt>:definite</tt>, <tt>:guessed</tt>, and
   <tt>false</tt> in this order

If the associated statuses are equal for two or more inputs, the most
extreme one among them for each polarity is chosen.  For example, suppose
two instances of {Rangeary} are given in initialization of another
{Rangeary} and their negative infinities are "+b+" and "+c+".  Then,
because of

  "b" < "c"

the former ("+b+") is adopted as the new negative infinity.  Note that
the parameters given in the optional arguments have always higher
priority regardless.


The following examples demonstrate the specification.

  Rangeary(7..).negation
    # => Rangeary(-Float::INFINITY...7)
  Rangeary(7..).negation.negation
    # => Rangeary(7..)

Remember the default infinity for Float is +Float::INFINITY+. In this
case, however, the positive infinity was in practice specified by the
user to be +nil+ in the form of argument of +(7..)+ If you want to
specify the negative infinity instead, you must do it explicitly: 

  Rangeary(7.., negative: nil).negation
    # => Rangeary(...7)

Alternatively, you can always use cojunction like (the following two mean the same):

  Rangeary(..nil).conjunction(Rangeary(7..)).negation
    # => Rangeary(...7)
  ~(Rangeary(..nil) * Rangeary(7..))
    # => Rangeary(...7)

The registered infinities for each instance is obtained (Hash extended with
HashInf), which has
two keys of +:positive+ and +negative+, with the method {#infinities};
for example,

  ran.infinities
    # => <Hash(Inf): {:negative=>"a", :positive=>nil},
    #     status: {:negative=>:definite, :positive=>:guessed}>

Note that the values of the returned Hash (+HashInf) may be +false+;
if it is not convenient, call it as +#instances(convert: true)+
with which +false+ in the returned value, if there is any, is converted
to +nil+ and the standard Hash as opposed to
Hash extended with {Rangeary::Util::HashInf} is returned:

  ran.infinities(convert: true)  # => { :negative => "a"
                                 #      :positive => nil, }

Consults the manuals of the methods for detail.


===  Array#==

Equal method of +Array#==+ (and thus its child-class +Rangeary#==+) is
modified slightly so that the behaviour when both are *practically*
empty.

Rangeary objects are never empty in the sense of Array; it contains at
least +RangeExtd::NONE+, which is *empty*.  Therefore, if either or
both the Array/Rangeary return true with {Rangeary#empty_element?},
then it is regarded as equivalent to +Array#empty?+.

Up to Ver.1 (or more precisely, in Ver.1),, the equality behaviour was
far more complicated. The complexity originated in the incompleteness
of the Ruby built-in borderless Range;
while Ruby-2.6 introduced the endless Range, which Rangeary Ver.1 supported,
it lacked the beginless Range till the release of Ruby-2.7.

Since Rangeary Ver.1 implemented only the endless Range, logical
operations, especially those that involve negation either explicitly
or implicitly (like subtraction), were self-incomplete.  To mitigate
the problem, the equality method was designed to handle the
incompleteness instead in Rangeary Ver.1.0.

Now that both beginless and endless Ranges are supported by Ruby and
Rangeary Ver.2, such an ad hoc fix is no longer necessary or
desirable. The difference from the Ruby default is now minimum.

Note that this library loads the utility library associated with
+RangeExtd+, which modifies some behaviours of the equality method
(operator) of all Object, if in a backward-compatible way, i.e., users
do not have to worry about it for the use outside RangeExtd. For
logical operations implemented in this library, commutative behaviours
of the operators are essential and they would be only achieved by
modifying +Object#==+.

Also note that +Rangeary#equiv+ method may behave differently from the equal operator.
For example, 

   Rangeary(RangeExtd(1,"<...",4), 5...8).equiv?(Rangeary(2..3, 5..7))

returns true.  To describe this, the left and right Rangearies are arrays of
ranges of Integers which consist of

* (Left)
  1. Range that starts at, but excluding, 1, ending at, but excluding 4
  2. Range that starts at 5 (inclusive), ending at 8 (exclusive).
* (Right)
  1. Range that starts and ending at 2 and 3, respectively, both inclusive.
  2. Range that starts and ending at 5 and 7, respectively, both inclusive.

According to +Integer#succ+ (+Range#each+) method, the left and right ones are equivalent.
Therefore +Rangeary#equiv+ returns true, wheras the equal operator
returns false for this.


== Known bugs

* Rangeary Ver.2, which supports both beginless and endless Ranges, requires {RangeExtd}[https://rubygems.org/gems/range_extd] Ver.2 or later.
* To suppress warnings in Ruby-2.7 (in Rangeary Ver.1), {RangeExtd}[https://rubygems.org/gems/range_extd] must be Ver.1.1.1 or later.
* +Rangeary#last_element+ includes a monkey patch (which used to raise
  an error before Rangeary Ver.2) to handle a bug in +Range#last+ in Ruby-2.7
  and above (at least up to 3.1.2).  See
  {Bug #18994}[https://bugs.ruby-lang.org/issues/18994] for detail of the bug,
  which was in no time resolved with ({patch #6324}[https://github.com/ruby/ruby/pull/6324],
  applied at commit {bbe5ec7}[https://github.com/ruby/ruby/commit/bbe5ec78463f8d6ef2e1a3571f17357a3d9ec8e4]).
  It happens only in very limited conditions.

This library (for Ver.2 and later) requires Ruby 2.7 or later.

Extensive tests have been performed, as included in the package.


== ToDo

Nothing planned.


== Final comment

This work is inspired by Ian Stewart, who developped a (numeric)
multiple-range library in Fortran90 for the SAS software package for
XMM-Newton telescope.  I appreciate his work.

The implementation to Ruby was not straightforward, though, partly
because the built-in Range does not allow to exclude the begin
boundary, and partly because the infinity is not defined for general
objects but Numeric (Real) in Ruby (which later changed partially with
the introduction of Endless Range in Ruby 2.6 released in 2018
December and further and completely with the introduction of Beginless Range in Ruby
2.7 released in 2019 December).  +RangeExtd+ class I have developed
makes this library possible.  I am glad the completeness of ranges in
the 1-dimensional space for arbitrary Comparable object is achieved now.

Enjoy.



== Miscellaneous

== Copyright etc

Author::  Masa Sakano < info a_t wisebabel dot com >
License:: MIT.
Warranty:: No warranty whatsoever.
Versions:: The versions of this package follow Semantic Versioning (2.0.0) http://semver.org/

-------------------------------------------

= Rangeary - 複数Range(Extd)クラス

このパッケージは、1次元の任意の数のレンジ({RangeExtd}[http://rubygems.org/gems/range_extd] オブジェクト)を
保持する Rangeary クラスを定義しています。たとえば、<tt>x</tt> に
対する複数レンジの
   0.5 < x <= 2.5,  6.0 <= x < 8.0,  10.0 <= x (<= 無限大)
がこのクラスで定義できます。

RangeExtd の要素たり得るオブジェクトは全て {Rangeary} の要素となり
得ます。Numeric(の実数)に限らず、Comparable であるオブジェクトは全て
可能です。また、{Rangeary} は、組込Rangeクラスのオブジェクトも初期化に
使えます。

四つの標準論理演算全て、すなわち否定(negation; <tt>~</tt>)、論理積
(conjunction; <tt>&</tt> または <tt>*</tt>)、論理和(disjunction;
<tt>|</tt> または <tt>+</tt>)および排他的論理和(exclusive disjunction;
<tt>^</tt> または <tt>xor</tt>)、またそれに加えて引き算(subtraction;
<tt>-</tt>)が、定義されています。

{Rangeary} オブジェクトはイミュータブルです。すなわち、
一度インスタンスが生成されると、要素を書換えることはできません。

実用的には、{Rangeary} は、Arrayのサブクラスとなっていて、RangeExtd
の配列として振舞います。また、Arrayのほとんどのメソッドを継承していま
す。したがって、イミュータブルな{Rangeary}に許される限りにおいて、
Arrayに使えるほとんどの操作を{Rangeary}に適用できます。加えて、
{Rangeary}には、そのレンジの要素に直接働きかけるメソッドも幾つかあり
ます。上に挙げた例ならば、<tt>#cover?(1.0)</tt> は真を返し、
<tt>#cover?(9.0)</tt> は偽を返します。

このクラスにより、1次元レンジへの論理演算が可能かつ容易になりました。
これが有用なものであることを願ってここにリリースします。


== インストール

まず、RangeExtd クラスのライブラリ(純粋に rubyで書かれたファイル 2個
です)が必要です。gem を使ってインストールできます。
  gem install range_extd
もしくは以下から入手して下さい。
https://rubygems.org/gems/range_extd

次いで、このライブラリをインストールします。
  gem install rangeary

ファイルが一つ、
  rangeary/rangeary.rb
<tt>$LOAD_PATH</tt>上のどこかにインストールされるはずです。 
あるいは以下から入手可能です。
http://rubygems.org/gems/rangeary

後は、Ruby のコード(又は irb)から
  require 'rangeary/rangeary'
とするだけです。もしくは、特に手でインストールした場合は、
  require 'rangeary'
とする必要があるかも知れません。他のファイル(RangeExtd 用の
<tt>range_extd/range_extd.rb</tt>)は、自動的に読込まれます。

{Rangeary} は Ruby 2.1 以上で動きます。

お楽しみあれ!


== 単純な使用例

=== Rangeary インスタンスを作成する方法

以下に幾つかの基本的な使用例を列挙します。

   r1 = RangeExtd(?a...?d, true) # => a<...d
   ra = Rangeary(?g..?h, r1)     # => [a<...d, g..h]
   Rangeary(RangeExtd::NONE)     # => [RangeExtd::NONE]
   Rangeary(RangeExtd::NONE, 1..5, 3...7)  # => [1...7]
   Rangeary(true..true)          # => ArgumentError

基本的に、<tt>Rangeary()</tt> または <tt>Rangeary.new()</tt> は、任意
の数の Range、RangeExtd、{Rangeary} あるいはその組合わせを引数とし
て取ります。ただし、Rangeクラスのオブジェクトで +Range#valid?+ が偽
を返すものは、例外が発生します。

さらなる解説及び例は、{Rangeary.initialize}を参照して下さい。


=== 実践例

   ra.to_a                       # => ["a"<..."d", "g".."h"]
   ra.cover?("a")                # => false
   ra.cover?("b")                # => true
   ra.end                        # => "h"
   ra.each do |i|
     print i.begin
   end    # => self ( "ag" => STDOUT )
   ra.each_element do |i|
     print i
   end    # => self ( "bcgh" => STDOUT )

   rb = Rangeary(6...9, 2..4)    # => [2..4, 6...9]
   rb + Rangeary(3..7)           # => [2...9]
   rb - Rangeary(3..7)           # => [2...3, RangeExtd(7,'<...',9)]
   rb * Rangeary(4..5, 8..10)    # => [4..4, 8...9]
   ~rb                           # => [-Float::INFINITY...2, RangeExtd(4,'<...',6), 9..Float::INFINITY]

   rc = Rangeary(?d...?x, negative: ?a, positive: ?z)
   ~rc                           # => [?a...?d, ?x..?z]

ここで、+~rb+ は +rb.negation+ と等価で論理否定を意味します。最後の例
では、ユーザー指定の*無限大/無限小*値を定義しています。


組込Arrayクラスに含まれるほとんどのメソッドが、たとえば+Array#push+のように
{Rangeary} がイミュータブルであることに抵触しない限りにおいて、使用可能です。


== 詳説

ファイル <tt>rangeary.rb</tt> が読まれた段階で、RangeExtd ライブラリで
定義される二つのクラス(<tt>RangeExtd</tt> と
<tt>RangeExtd::Infinity</tt>)に加えて、クラス一つが定義されます。

* Rangeary


=== Rangeary クラス

{Rangeary} オブジェクトは、Range や RangeExtd と同様、イミュータブルで
す。だから、一度インスタンスが生成されると、変化しません。

インスタンスの生成方法は上述の通りです(「使用例」の章)。レンジとして"valid"と見
なされないインスタンスを生成しようとすると、すなわち +Range#valid?+ が
偽を返すレンジを使おうとすると、例外(<tt>ArgumentError</tt>)が発生し、
失敗します。

なお、ユーザーは、{Rangeary} インスタンス生成の時、レンジ要素に対応し
た正負の無限大オブジェクトを付加することができます。デフォルトでは、
+Float::INFINITY+ または +RangeExtd::Infinity::POSITIVE+ の類に
なります。詳しくは {Rangeary.initialize} を参照下さい。

生成時に複数のレンジが引数として与えられた時、ソートされて保持されます。
その時、要素のどこかに重複する部分があった時は、論理和として扱われます
(つまり、単純に足し合わされます)。これはつまり、{Rangeary} が内部的に
保持するオブジェクトは生成時に与えられたものとは異なる、すなわち
<tt>#object_id</tt> が異なるかも知れないことを意味します。特に、組込Rangeが引
数として与えられた時は、常に RangeExtd オブジェクトに内部で変換されます。

もし生成時に与えられたレンジのどれかが空、すなわち +Range#empty?+ が真
を返す場合、それらは無視されます。ただし、引数の全てのレンジが空であっ
た場合は、「最小」のものが残されます。

もし演算の結果として空の{Rangeary}が返される場合、その唯一の要素は
+RangeExtd::NONE+となり、したがって
{Rangeary#empty_element?} が真を返します。

そのため、どの Rangeary オブジェクトも、+Rangeary#to_a.size+ は常に正
の値を返し、零を返すことはありません。あるいは、Array から継承した
+Rangeary#empty?+ は常に偽を返します(オブジェクトがレンジとして空かど
うかをチェックするには、{Rangeary#empty_element?} を使って下さい)。
   Rangeary(RangeExtd::NONE).empty?          # => false
   Rangeary(RangeExtd::NONE).empty_element?  # => true

前述のように、ごく一部を除いた全ての Arrayクラスのメソッドがこの
{Rangeary} クラスに継承されていて、それらは各RangeExtd要素に対して
動作します。ただし、4個のメソッドの挙動が異なります。
{Rangeary#+} と {Rangeary#*} とは、それぞれ {Rangeary#disjunction} と
{Rangeary#conjunction} とへのエイリアスとなっています。{Rangeary#===}
は、全てのRangeExtd要素に対して+Range#===+を実行し、それらの一つでも
真を返せば真を返します。したがって、{Rangeary#===}(RangeExtd(**))は常
に偽を返します。
また、[#length] と [#reverse] とは未定義化されています。

{Rangeary#==} と +Rangeary#eql?+ は、Arrayと同様に動作します。だから
  [2..4, 6..8] == Rangeary(2..4, 6..8)  # => true
も成り立ちます。しかし注意すべきは以下です。
  [2..4, 6..8] == Rangeary(6..8, 2..4)  # => true
  [6..8, 2..4] == Rangeary(6..8, 2..4)  # => false
端的には、標準Arrayとの直接比較は推奨しません。代わりに、
{Rangeary} オブジェクトと比較して下さい。

レンジ要素に対してではなく、レンジを構成する要素に対して動作する他の
全てのメソッドは、組込Arrayクラスに同名のメソッドが存在する場合、接尾辞
<tt>_element</tt> がつきます。たとえば、+Rangeary#size+ は、保持する
RangeExtd オブジェクトの数を返し、一方、{Rangeary#size_element}は、
保持するすべての RangeExtdオブジェクトに対して +Range#size+ を行った
その総和を返します。
   Rangeary(1..3, 5..8).size          # => 2
   Rangeary(1..3, 5..8).size_element  # => 7

{Rangeary#flatten_element} は、全てのRangeExtd要素に対して
+Rangeary#to_a+ を実行して、その結果を結合した配列を返します。

クラスとメソッドの完全なマニュアルは、
{Rubygems のウェブサイト}[http://rubygems.org/gems/rangeary]上にあります。
あるいは、ソースパッケージを展開して、ルートディレクトリで +make doc+
することで、手元でコンパイルすることもできます(RubyGems の +yard+
がインストールされている必要があります)。

===  Array#==

等号メソッド +Rangeary#==+ は、Array とは異なった挙動をするべきであり、
実際します。まず、*empty?* の際の意味が、異なります。なぜならば、
Rangeary オブジェクトは、Array的な意味では、empty になることは決してな
いからです。次に、Ruby 2.6で導入された
{Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
は、概念的にそう素直には組み込まれません。例えば、Ruby 2.6 では以下の
ような挙動を示します。

  (?a..).size                  # => nil
  (10..).size                  # => Infinity
  (10..Float::INFINITY)).size  # => Infinity
  (1.0..) != (1.0..Float::INFINITY)

これらは、当たり前の挙動ではありませんし、若干矛盾があるとさえ言えるかも
知れません。Range#size メソッドに関しては、Numericクラス(Complexを除く)
のオブジェクトに関しては、Endless Range は、数学的無限のように振舞いま
す。しかし、両者を比較することはできず、等号比較すると、偽が返ります。

Rangeary は、複数の Range からなる数列(array)に対して、論理演算する機
能を提供します。そのためには、一貫した「無限」の定義が不可欠です。例え
ば、 +[5..Infinity]+ の否定は、

  [-Infinity...5]

すなわち、無限小から始まり、5 で終わるが、終端は含まれない、ということ
になります。これに対して再度否定演算を行うと、元の Rangeary +(5..Infinity)+
が再度得られなければなりません。

この演算は、当然、+Endless Range+ だけでは不可能です。+Endless Range+
は正の無限大、あるいは正確には、正の方向に開いたもの、しか定義していないからです。
このため、+RangeExtd+ を使用することは、Rangeary では決定的に重要なの
です。

Rangearyの演算(ここでは否定演算)においては、以下のようになります。

  r1 =   Rangeary(5..)   # => [(5..)]  (equivalent to (5..nil))
  r2 =  ~Rangeary(5..)   # => [(-Float::INFINITY...5)]
  r3 = ~~Rangeary(5..)   # => [(5..Float::INFINITY)]

  r4 =   Rangeary(?a..)  # => [(?a..)]  (equivalent to (?a..nil))
  r5 =  ~Rangeary(?a..)  # => [(RangeExtd::Infinity::NEGATIVE...?a)]
  r6 = ~~Rangeary(?a..)  # => [(?a..RangeExtd::Infinity::POSITIVE)]

この演算において、負の無限大も経過した最後の結果が、元々の出発点である(Ruby2.6で言う)
Endless Rangeにならなければいけない理由はないことになります。しかしながら、
+r1==r3+ および +r4==r6+ は成立すべきです。

+RangeExtd#==+ は、+Range#==+ とほぼ同一に振舞います(前者は
+exclude_begin+ メソッドを持つことを除いて)。例えば、

           (1.0..) !=          (1.0..Float::INFINITY)
  RangeExtd(1.0..) != RangeExtd(1.0..Float::INFINITY)

+r1==r3+ や +r4==r6+ も成立するよう、数学的一貫性を保つために、Rangeary では、
等号の定義を変更する必要がありました。Array クラスのデフォルトの標準等
号ではダメだからです。
そこで、Rangeary では、Endless Range と終端が何か別の無限大である
Rangeとは、他のパラメーター(例えば始端や+exclude_end+)が等しい限り、等
しいと見なします。

実装としては、本ライブラリ内で +Array#==+ (Rangearyに自然に継承される)を変更しています。
そのため、等号の可換性が保たれています。

なお、+Rangeary#equiv+ メソッドは、等号とは異なる挙動をすることがあり
ます。例えば、

   Rangeary(RangeExtd(1,"<...",4), 5...8).equiv?(Rangeary(2..3, 5..7))

は真になります。以下のような説明になります。左右の Rangearyは、整数の
Rangeからなる配列で、

* (左側の Rangeary)
  1. 始端が1 (但し始端自体は含まない)で、終端が4 (但し終端自体は含まない)
  2. 始端が5 (始端を含む)で、終端が8 (但し終端自体は含まない)
* (右側の Rangeary)
  1. 始端が2、終端が3 (両端を含む)
  2. 始端が5、終端が7 (両端を含む)

+Integer#succ+ (あるいは、+Range#each+)メソッド的には、左側と右側とは等価です。したがって、
+Rangeary#equiv+ でこの両者を比較すると真を返します。一方、等号は負を
返します。

===  無限大

正負の無限大は、Rangearyの演算に不可欠です。デフォルトでは、正負の一般無限大は
<tt>RangeExtd::Infinity::POSITIVE</tt> と <tt>RangeExtd::Infinity::NEGATIVE</tt>
が使われます(詳細は {RangeExtd}[http://rubygems.org/gems/range_extd] 参照)。
但し、例外が、比較可能な Numerics (Integer, Rational, Floatなど)で、
+Float::INFINITY がデフォルトで使われます。しかし、ユーザーは、オブジェ
クト作成の時、+positive:+ および +negative:+ で自分の無限大を定義することもできます。

なお、一旦、無限大が定義されると、そのオブジェクトと演算を行う全ての
Rangearyオブジェクトも同じ無限大をもつべきです。デフォルトでは、演算す
るオブジェクト間でもし異なる無限大が使われている場合(端的には、一つの
オブジェクトにだけ無限大を定義して他はデフォルトで済ませている場合)は、
正の無限大には最小の値、負の無限大には最大の値が選ばれます。但し、警告
メッセージが出るかもしれません(組込グローバル変数 +$VERBOSE+が真の時のみ)。
例外は、複数のRangearyから新しいRangeryオブジェクトを作成の際に、オプ
ションで陽に無限大を指定した時で、その時は、それらRangearyから継承した
値は考慮されず、指定した値が使われます。

上記の最後の例が、指定する例です。

== 既知のバグ

* Ruby-2.7 で警告を出さないためには、{RangeExtd}[https://rubygems.org/gems/range_extd] は、Ver.1.1.1 以上であること。
* <tt>Rangeary.new(-6..-5, 2..5, 8..8).last_element(3)</tt> は、
      Ruby-2.6.x 以前は正しい値を返すが、Ruby-2.7 ではなぜか <tt>[3, 4, 5]</tt> と誤った値を返す。

このライブラリは Ruby 2.1 以上を必要とします。

パッケージに含まれている通り、網羅的なテストが実行されています。


== 未処理事項

特になし。


== 終わりに

このライブラリは、イアン・スチュワート氏が開発した、XMM-Newton望遠鏡用の
SAS解析ソフトウェア・パッケージに含まれる(数値)複数レンジの
Fortran90ライブラリにアイデアを得たものです。彼の仕事に感謝します。

しかし、Rubyへの実装は、一筋縄ではいきませんでした。一つには組込Range
クラスでは始点を除外することができないこと、また一つには Rubyでは数値
を除いて一般オブジェクトに対しての無限大が定義されていないからです。
小生の開発した RangeExtd によって初めてこのライブラリが可能となりま
した。これにより、今、比較可能な任意のオブジェクトについて、1次元上の
レンジの完全性が実現できたことを嬉しく思います。

お楽しみ下さい。


== その他

== 著作権他情報

著者::  Masa Sakano < info a_t wisebabel dot com >
利用許諾条項:: MIT.
保証:: 一切無し。
バージョン:: Semantic Versioning (2.0.0) http://semver.org/

